<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javascript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="摘要书中介绍了创建对象的7种模式，着重介绍前面4种，后面3种貌似不常用。前面4种模式的出场顺序都是遵循着为了解决前一种模式出现的问题而出现的。">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象二之创建对象">
<meta property="og:url" content="http://yoursite.com/2017/02/15/面向对象二之创建对象/index.html">
<meta property="og:site_name" content="来自南极的 Mr.Humor">
<meta property="og:description" content="摘要书中介绍了创建对象的7种模式，着重介绍前面4种，后面3种貌似不常用。前面4种模式的出场顺序都是遵循着为了解决前一种模式出现的问题而出现的。">
<meta property="og:updated_time" content="2017-02-16T08:58:09.933Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面向对象二之创建对象">
<meta name="twitter:description" content="摘要书中介绍了创建对象的7种模式，着重介绍前面4种，后面3种貌似不常用。前面4种模式的出场顺序都是遵循着为了解决前一种模式出现的问题而出现的。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/02/15/面向对象二之创建对象/"/>





  <title> 面向对象二之创建对象 | 来自南极的 Mr.Humor </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">来自南极的 Mr.Humor</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-board">
          <a href="/board" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />
            
            留言
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/15/面向对象二之创建对象/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Nikolaus Liu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="来自南极的 Mr.Humor">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="来自南极的 Mr.Humor" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                面向对象二之创建对象
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-15T09:32:57+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Javascript高程笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript高程笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/15/面向对象二之创建对象/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/15/面向对象二之创建对象/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>书中介绍了创建对象的7种模式，着重介绍前面4种，后面3种貌似不常用。前面4种模式的出场顺序都是遵循着为了解决前一种模式出现的问题而出现的。</p>
<a id="more"></a>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><p>当大量创建同类功能的对象时，最基本的创建对象的写法往往意味着大量重复的代码。为了解决这个问题，工厂模式应运而生。看代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  o.name = name;</div><div class="line">  o.age = age;</div><div class="line">  o.job = job;</div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(o.name);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'nikolaus'</span>,<span class="number">23</span>,<span class="string">'Frond-End'</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">'liuyu'</span>,<span class="number">20</span>,<span class="string">'Designer'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="工厂模式的问题"><a href="#工厂模式的问题" class="headerlink" title="工厂模式的问题"></a>工厂模式的问题</h3><p>上面的代码确实解决了大量重复代码的问题，而且可以在每次创建一个对象实例的时候传入参数。但是这种方式无法识别出这些实例对象是出于同一类的。只能知道它们都是Object对象的实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><h3 id="写法-1"><a href="#写法-1" class="headerlink" title="写法"></a>写法</h3><p>为了解决工厂模式中出现的问题，我们可以采用构造函数模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nikolaus'</span>,<span class="number">23</span>,<span class="string">'Frond-End'</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'liuyu'</span>,<span class="number">20</span>,<span class="string">'Designer'</span>);</div></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>构造函数模式与工厂模式的区别在于：</p>
<ul>
<li>没有显示的创建对象这一步，即<code>var o = new Object();</code>。</li>
<li>构造函数模式直接将属性和方法赋给this对象。</li>
<li>没有return语句。</li>
<li>构造函数的函数名首字母是大写的(其实这只是一个规范，写成小写也并没有语法错误)。</li>
</ul>
<p>在用构造函数创建一个对象实例时，实际上在javascript引擎中经历了以下几步：</p>
<ul>
<li>创建一个新的空的对象(这个对象是不是用<code>new Object()</code>来创建的我就不知道了)。</li>
<li>把构造函数的作用域赋给新对象(因此，this指向新对象)。</li>
<li>执行构造函数内部的代码(也就是为新对象添加属性和方法)。</li>
<li>返回全新的对象。</li>
</ul>
<h3 id="构造函数也是函数"><a href="#构造函数也是函数" class="headerlink" title="构造函数也是函数"></a>构造函数也是函数</h3><p>实际上我们可以用下面的代码来模拟这个过程，虽然我不知道它底层是不是这样实现的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Person.say(person1,<span class="string">'nikolaus'</span>,<span class="number">23</span>,<span class="string">'Frond-End'</span>);</div></pre></td></tr></table></figure></p>
<p>关于<code>call()</code>和<code>apply()</code>，可以参见我的另一篇文章：<a href=""></a></p>
<p>构造函数本质上还是一个函数。除了上面的那种用say来延长其作用域的用法，我们也可以直接调用，就像下面这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person(<span class="string">'nikolaus'</span>,<span class="number">23</span>,<span class="string">'Frond-End'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name);  <span class="comment">//nikolaus</span></div></pre></td></tr></table></figure></p>
<p>由于是在全局作用域中执行的函数。this就指向了window，这个过程就相当于为window添加了若干属性和方法。</p>
<h3 id="构造函数模式的问题"><a href="#构造函数模式的问题" class="headerlink" title="构造函数模式的问题"></a>构造函数模式的问题</h3><blockquote>
<p>“一切皆对象”。</p>
</blockquote>
<p>javascript中的函数也是对象，所有的函数都是<code>Function</code>的实例，所以上面例子的代码可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>()&#123;<span class="string">"console.log(this.name);"</span>&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nikolaus'</span>,<span class="number">23</span>,<span class="string">'Frond-End'</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'liuyu'</span>,<span class="number">20</span>,<span class="string">'Designer'</span>);</div></pre></td></tr></table></figure></p>
<p>这样，问题就很明显了：每次创建一个<code>Person</code>的实例对象的时候，都会在实例对象内部重新创建一个<code>Function</code>的实例，它们的功能是一样的，但是它们并不来自一个引用，通过下面的代码可以看出这一点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName);  <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>其实，解决这个问题也不难，我们可以把方法的声明拿到构造函数外面，让方法保存的只是一个指针，这样，多个实例对象的方法就是共用的了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.sayName = sayName;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>没错，是解决了。但是一个全局的函数只是作为一个对象的方法而存在的，这对全局作用域是一种侮辱。而且如果对象要定义很多的方法，就要向全局作用域添加很多变量，严重污染了全局作用域，这个类也就毫无封装性可言了。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="写法-2"><a href="#写法-2" class="headerlink" title="写法"></a>写法</h3><p>原型模式可以很好的解决构造函数模式存在的问题，先看代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype.name = <span class="string">'nikolaus'</span>;</div><div class="line">Person.prototype.age = <span class="number">23</span>;</div><div class="line">Person.prototype.job = <span class="string">'Front-End'</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure></p>
<p>我们创建的每个函数都有一个prototyp属性，这个属性是一个指针，指向一个对象，这个对象保存了特定类型的所有实例的共有的属性和方法。要理解原型模式，必须要先理解原型对象。</p>
<h3 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h3><h4 id="各种概念"><a href="#各种概念" class="headerlink" title="各种概念"></a>各种概念</h4><p>这一块有很多概念，如果不理解，很容易混淆，所以我单独把这些概念拎出来：</p>
<ul>
<li>prototype属性</li>
<li>原型对象prototype</li>
<li>constructor属性</li>
<li>构造函数(Person)</li>
<li>实例对象(person1)</li>
<li>内部属性[[prototype]]</li>
<li>__proto__属性(左右各两个下划线)</li>
</ul>
<p>所有的函数在被创建的时候，引擎都会为它创建一个<strong>原型对象prototype</strong>，前面说过每个函数都有一个<strong>prototype属性</strong>，这个<strong>prototype属性</strong>就是指向<strong>原型对象prototype</strong>的一个指针。当<strong>原型对象prototype</strong>被创建时，会自动的为它添加一个<strong>constructor属性</strong>，其他的方法都是继承自Object。<strong>constructor属性</strong>也是一个指针，指回<strong>构造函数</strong>。<strong>实例对象</strong>又有一个<strong>内部属性[[prototype]]</strong>，这个属性也是一个指针，指向<strong>构造函数</strong>的<strong>原型对象prototype</strong>。但是这个<strong>内部属性[[prototype]]</strong>并没有标准的方式来访问它，Chrome、Safari、Firefox在每个对象上支持一个<strong>__proto__属性</strong>，在其他实现中，这个属性对脚本不可见。</p>
<p>好了，到此为止，是不是晕了，反正我当时是晕了，花了好久才捋清它们之间的关系:</p>
<ul>
<li>只有函数有<strong>prototype属性</strong>，对象没有，对象有的是<strong>内部属性[[prototype]]</strong></li>
<li><strong>原型对象prototype</strong>和<strong>实例对象</strong>都有<strong>constructor属性</strong>（当然，实例对象继承自原型对象，下面讲），而且都指向<strong>构造函数</strong>。</li>
<li>Person.prototype = 原型对象prototype</li>
<li>Person.prototype.constructor = Person = person1.constructor</li>
<li>person1.__proto__ = Person.prototype</li>
</ul>
<h4 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h4><p>我们已经知道在一些实现中，我们无法访问到[[prototype]]，但是我们可以用<code>isPrototypeOf()</code>方法来检测<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1));  <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>ECMAScript为我们提供了<code>Object.getPrototypeOf()</code>方法来返回[[prototype]]的值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(Person.prototype == <span class="built_in">Object</span>.getPrototyeOf(person1));  <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>在访问一个实例对象的属性或方法的时候时候实际上是一系列的搜索过程。还是以上面的实例代码为例。当访问<code>person1.name</code>的时候，引擎会先到person1的实例上去找，如果找到了，就会直接返回找到的结果，咱就不继续找了。可是由于name属性是定义在原型上的，并不是实例属性，所以在实例上找不到，找不到就往它上一层的原型中找，找到了，就返回，找不到，继续往上，一直找到Object的原型中去。这中查找是按照一种链式来查找的，这个链就是原型链。</p>
<h4 id="实例不能修改原型属性，只能屏蔽原型属性（只对于基本简单数据类型）"><a href="#实例不能修改原型属性，只能屏蔽原型属性（只对于基本简单数据类型）" class="headerlink" title="实例不能修改原型属性，只能屏蔽原型属性（只对于基本简单数据类型）"></a>实例不能修改原型属性，只能屏蔽原型属性（只对于基本简单数据类型）</h4><p>我们已经知道，通过实例我们可以访问保存在原型中的属性，但并不能修改原型属性。在实例上定义原型中的同名属性，会阻止我们访问原型中的这个属性，因为沿着原型链的查找会在实例中停止。要恢复对这个原型属性的访问，只能通过<code>delete</code>操作符删除这个实例属性来实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype.name = <span class="string">'nikolaus'</span>;</div><div class="line">Person.prototype.age = <span class="number">23</span>;</div><div class="line">Person.prototype.job = <span class="string">'Front-End'</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person1.name = <span class="string">'niko'</span>;</div><div class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">//niko</span></div><div class="line"><span class="built_in">console</span>.log(person2.name);  <span class="comment">//nikolaus</span></div><div class="line"><span class="keyword">delete</span> person1.name;</div><div class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">//nikolaus</span></div></pre></td></tr></table></figure></p>
<h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h4><p><code>hasOwnProperty()</code>方法可以用来检测属性是存在于原型中还是存在于实例中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype.name = <span class="string">'nikolaus'</span>;</div><div class="line">Person.prototype.age = <span class="number">23</span>;</div><div class="line">Person.prototype.job = <span class="string">'Front-End'</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person1.name = <span class="string">'niko'</span>;</div><div class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">'name'</span>));  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">'name'</span>));  <span class="comment">//false</span></div><div class="line"><span class="keyword">delete</span> person1.name;</div><div class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">'name'</span>));  <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h3 id="原型与in操作符"><a href="#原型与in操作符" class="headerlink" title="原型与in操作符"></a>原型与in操作符</h3><p>有两种使用in操作符的方式：单独使用和在for-in循环中使用。</p>
<h4 id="单独使用"><a href="#单独使用" class="headerlink" title="单独使用"></a>单独使用</h4><p>单独使用in操作符时，对象在能够访问到给定属性时返回true，无论这个属性存在于实例中还是存在于原型中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person1.name = <span class="string">'niko'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1);  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person2);  <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>结合使用in操作符和<code>hasOwnProperty()</code>方法，可以确定一个属性是否存在于实例中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">obj,propertyName</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> !obj.hasOwnProperty(propertyName) &amp;&amp; (propertyName <span class="keyword">in</span> obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回true就说明属性只存在于实例中</p>
<h4 id="在for-in循环中使用"><a href="#在for-in循环中使用" class="headerlink" title="在for-in循环中使用"></a>在for-in循环中使用</h4><p>for-in循环会返回所有对象可以访问、可以枚举（即[[ennumerable]]为true）的属性，无论这个属性是存在于实例中还是存在于原型中。如果实例中重写了继承自Object的方法，这个方法会变为可枚举属性。因为按照规定，<strong>所有用户自定义的属性都是可枚举的</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">toString</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> o)&#123;</div><div class="line">  <span class="keyword">if</span>(prop == <span class="string">'toString'</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Found toString'</span>);  <span class="comment">//Found toString</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>要想获取对象上所有可枚举的实例属性，需要用到<code>Object.keys(obj)</code>方法，这个方法返回一个由所有可枚举属性组成的字符串数组。</p>
<h4 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h4><p>要获取对象上所有的实例属性，而无论属性是否可枚举，可以用<code>Object.getOwnPropertyNames(obj)</code>方法，返回值也是字符串数组。</p>
<h3 id="更简单的原型模式写法"><a href="#更简单的原型模式写法" class="headerlink" title="更简单的原型模式写法"></a>更简单的原型模式写法</h3><p>上面例子中在使用原型模式为对象添加属性和方法的时候，需要写多次<code>Person.prototype</code>，很麻烦。使用对象字面量的写法可以简化这个过程：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">name</span> : <span class="string">'nikolaus'</span>,</div><div class="line">  <span class="attr">age</span> : <span class="number">23</span>,</div><div class="line">  <span class="attr">job</span> : <span class="string">'Front-End'</span>,</div><div class="line">  <span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>但是，有一个问题。我们前面说过，所有函数创建的时候，引擎都为它创建了一个原型对象prototype，原型对象prototype的constructor属性又指向构造函数<code>Person.prototype.constructor = Person</code>。但是，这里用字面量的写法，就相当于重写了构造函数的原型对象。可以这样理解：有两个原型对象，一个是开始引擎创建的默认的原型对象，就叫他旧的原型对象吧；一个是用户自己用字面量形式创建的对象，我们称他为新的原型对象。现在用户把新的原型对象赋值给了构造函数的prototype属性，就切断了构造函数与旧的原型对象之间的关系。所以，现在的原型对象的constructor属性就不再指向构造函数了，我们需要手动的把它指回构造函数,像下面这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span> : Person</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>但是，新的问题又出现了，还记得上面我们说过<strong>所有用户自定义的属性都是可枚举的</strong>吗？constructor属性本来是继承自Object的，是不可枚举的，现在被用户重写后，这个属性变为可枚举的了，我们可以用<code>Object.defindeProperty()</code>来定义这个属性:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">'constructor'</span>,&#123;</div><div class="line">  <span class="attr">enumerable</span> : <span class="literal">false</span>,</div><div class="line">  <span class="attr">value</span> : Person</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在这里记住一点：<strong>字面量写法不是在原有的原型对象上增删属性，而是把一个新的对象赋值给了构造函数的prototype属性，这实际上是重写了原型对象，切断了构造函数与原有的原型对象之间的连接</strong></p>
<h3 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h3><p>由于实例对象是继承自原型对象的，所以，原型的改变会立即反映在所有继承自它的实例对象上，即使这个实例对象是在原型对象发生改变之前被创建的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">//nikolaus</span></div><div class="line">Person.prototype.name = <span class="string">'liuyu'</span>;</div><div class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">//liuyu</span></div></pre></td></tr></table></figure></p>
<p>但是，不能使用字面量写法,原因参考上面说过的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">//nikolaus</span></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">name</span> : <span class="string">'liuyu'</span>;</div><div class="line">&#125;；</div><div class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">//nikolaus</span></div></pre></td></tr></table></figure></p>
<h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><p>我们所熟知的原生的引用类型（如Array、Date等）也是用原型来定义的，所以我们可以在通过原型来访问这些引用类型的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort);        <span class="comment">//function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.subString);  <span class="comment">//function</span></div></pre></td></tr></table></figure></p>
<p>我们还可以在这些原生的引用类型的原型上定义方法，当然，这并不推荐：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) == <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> msg = <span class="string">"hello world"</span>;</div><div class="line"><span class="keyword">var</span> t = <span class="string">"hello"</span>;</div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(t));  <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h3 id="原型模式的问题"><a href="#原型模式的问题" class="headerlink" title="原型模式的问题"></a>原型模式的问题</h3><p>原型模式也是有缺点的。首先，它省去了构造函数模式中的传参这一步，使得所有同类型的实例对象最初都只能去到默认一样的值。当然，这还不是原型模式的主要问题，原型模式的主要问题是由其共享的特性导致的。</p>
<p>原型模式可以使得多个实例对象共享属性和方法。一般地，我们确实希望方法可以被多个实例对象共享，但是希望每个对象拥有各自不同的实例属性。对于包含简单数据类型值的属性，也还能说的过去。因为，毕竟我们还可以通过在实例对象上定义同名属性来屏蔽原型上的属性。但是，对于包含引用类型值的属性，就有问题了:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span> : Person,  <span class="comment">//这里就不管它的[[enumerable]]了，知道就好</span></div><div class="line">  name : <span class="string">'nikolaus'</span>,</div><div class="line">  <span class="attr">friends</span> : [<span class="string">'Jan'</span>,<span class="string">'anton'</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person1.friends.push(<span class="string">'Tobias'</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.friends);  <span class="comment">//'Jan,anton,Tobias'</span></div><div class="line"><span class="built_in">console</span>.log(person2.friends);  <span class="comment">//'Jan,anton,Tobias'</span></div></pre></td></tr></table></figure></p>
<p>可见，并不能通过实例来屏蔽原型中包含引用类型值的属性，而是会修改，这会反应在所有的实例中，并不是我们想看到的。</p>
<h2 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h2><p>最常见的创建自定义类型的方式，就是组合使用构造函数和原型模式。应该属于实例对象私有的属性用构造函数定义，共有属性和方法在原型对象上定义。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span> : Person,</div><div class="line">  <span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span></div></pre></td></tr></table></figure></p>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><!-- more -->
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/14/基于jquery的选项卡封装-插件/" rel="next" title="基于jquery的选项卡封装(插件)">
                <i class="fa fa-chevron-left"></i> 基于jquery的选项卡封装(插件)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <!-- 多说评论框 start -->
        <div class="ds-thread" data-thread-key="2017/02/15/面向对象二之创建对象/" data-title="面向对象二之创建对象" data-url="http://yoursite.com/2017/02/15/面向对象二之创建对象/"></div>
      <!-- 多说评论框 end -->
      <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
      <script type="text/javascript">
      var duoshuoQuery = {short_name:"nikolausliu"};
        (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0] 
           || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
        </script>
      <!-- 多说公共JS代码 end -->

    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Nikolaus Liu" />
          <p class="site-author-name" itemprop="name">Nikolaus Liu</p>
          <p class="site-description motion-element" itemprop="description">Love life,love coding.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/nikolausliu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#摘要"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#工厂模式"><span class="nav-number">2.1.</span> <span class="nav-text">工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#写法"><span class="nav-number">2.1.1.</span> <span class="nav-text">写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂模式的问题"><span class="nav-number">2.1.2.</span> <span class="nav-text">工厂模式的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数模式"><span class="nav-number">2.2.</span> <span class="nav-text">构造函数模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#写法-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区别"><span class="nav-number">2.2.2.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数也是函数"><span class="nav-number">2.2.3.</span> <span class="nav-text">构造函数也是函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数模式的问题"><span class="nav-number">2.2.4.</span> <span class="nav-text">构造函数模式的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型模式"><span class="nav-number">2.3.</span> <span class="nav-text">原型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#写法-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解原型对象"><span class="nav-number">2.3.2.</span> <span class="nav-text">理解原型对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#各种概念"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">各种概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#isPrototypeOf-NaN"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">isPrototypeOf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-getPrototypeOf"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">Object.getPrototypeOf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型链"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例不能修改原型属性，只能屏蔽原型属性（只对于基本简单数据类型）"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">实例不能修改原型属性，只能屏蔽原型属性（只对于基本简单数据类型）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hasOwnProperty-NaN"><span class="nav-number">2.3.2.6.</span> <span class="nav-text">hasOwnProperty()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型与in操作符"><span class="nav-number">2.3.3.</span> <span class="nav-text">原型与in操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单独使用"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">单独使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在for-in循环中使用"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">在for-in循环中使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-keys"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">Object.keys()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-getOwnPropertyNames"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">Object.getOwnPropertyNames()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更简单的原型模式写法"><span class="nav-number">2.3.4.</span> <span class="nav-text">更简单的原型模式写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型的动态性"><span class="nav-number">2.3.5.</span> <span class="nav-text">原型的动态性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原生对象的原型"><span class="nav-number">2.3.6.</span> <span class="nav-text">原生对象的原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型模式的问题"><span class="nav-number">2.3.7.</span> <span class="nav-text">原型模式的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合使用构造函数和原型模式"><span class="nav-number">2.4.</span> <span class="nav-text">组合使用构造函数和原型模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态原型模式"><span class="nav-number">2.5.</span> <span class="nav-text">动态原型模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#寄生构造函数模式"><span class="nav-number">2.6.</span> <span class="nav-text">寄生构造函数模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#稳妥构造函数模式"><span class="nav-number">2.7.</span> <span class="nav-text">稳妥构造函数模式</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nikolaus Liu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"nikolausliu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


</body>
</html>
